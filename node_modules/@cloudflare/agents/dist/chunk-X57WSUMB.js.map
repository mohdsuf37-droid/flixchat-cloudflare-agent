{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  Server,\n  routePartykitRequest,\n  type PartyServerOptions,\n  getServerByName,\n  type Connection,\n  type ConnectionContext,\n  type WSMessage,\n} from \"partyserver\";\n\nimport { parseCronExpression } from \"cron-schedule\";\nimport { nanoid } from \"nanoid\";\n\nexport type { Connection, WSMessage, ConnectionContext } from \"partyserver\";\n\nimport { WorkflowEntrypoint as CFWorkflowEntrypoint } from \"cloudflare:workers\";\n\nexport class WorkflowEntrypoint extends CFWorkflowEntrypoint {}\n\nexport type Schedule<T = string> = {\n  id: string;\n  callback: string;\n  payload: T;\n} & (\n  | {\n      type: \"scheduled\";\n      time: number;\n    }\n  | {\n      type: \"delayed\";\n      time: number;\n      delayInSeconds: number;\n    }\n  | {\n      type: \"cron\";\n      time: number;\n      cron: string;\n    }\n);\n\nfunction getNextCronTime(cron: string) {\n  const interval = parseCronExpression(cron);\n  return interval.getNextDate();\n}\n\nconst STATE_ROW_ID = \"cf_state_row_id\";\n\nexport class Agent<Env, State = unknown> extends Server<Env> {\n  #state = undefined as State | undefined;\n  state: State | undefined;\n\n  static options = {\n    hibernate: true, // default to hibernate\n  };\n  sql<T = Record<string, any>>(\n    strings: TemplateStringsArray,\n    ...values: any[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw e;\n    }\n  }\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_state (\n        id TEXT PRIMARY KEY NOT NULL,\n        state TEXT\n      )\n    `;\n    const _this = this;\n    Object.defineProperty(this, \"state\", {\n      get() {\n        if (!_this.#state) {\n          const result = _this.sql<{ state: State | undefined }>`\n      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}\n    `;\n          const state = result[0]?.state as string;\n          if (!state) return undefined;\n          _this.#state = JSON.parse(state);\n          return _this.#state;\n        }\n        return _this.#state;\n      },\n      set(value: State | undefined) {\n        throw new Error(\"State is read-only, use this.setState instead\");\n      },\n    });\n\n    void this.ctx.blockConcurrencyWhile(async () => {\n      try {\n        // Create alarms table if it doesn't exist\n        this.sql`\n        CREATE TABLE IF NOT EXISTS cf_agents_schedules (\n          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),\n          callback TEXT,\n          payload TEXT,\n          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),\n          time INTEGER,\n          delayInSeconds INTEGER,\n          cron TEXT,\n          created_at INTEGER DEFAULT (unixepoch())\n        )\n      `;\n\n        // execute any pending alarms and schedule the next alarm\n        await this.alarm();\n      } catch (e) {\n        console.error(e);\n        throw e;\n      }\n    });\n\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = (connection: Connection, message: WSMessage) => {\n      if (\n        typeof message === \"string\" &&\n        message.startsWith(\"cf_agent_state:\")\n      ) {\n        const parsed = JSON.parse(message.slice(15));\n        this.#setStateInternal(parsed.state, connection);\n        return;\n      }\n      _onMessage(connection, message);\n    };\n\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = (connection: Connection, ctx: ConnectionContext) => {\n      // TODO: This is a hack to ensure the state is sent after the connection is established\n      // must fix this\n      setTimeout(() => {\n        if (this.state) {\n          connection.send(\n            `cf_agent_state:` +\n              JSON.stringify({ type: \"cf_agent_state\", state: this.state })\n          );\n        }\n        _onConnect(connection, ctx);\n      }, 20);\n    };\n  }\n\n  #setStateInternal(state: State, source: Connection | \"server\" = \"server\") {\n    this.#state = state;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})\n  `;\n    this.broadcast(\n      `cf_agent_state:` +\n        JSON.stringify({\n          type: \"cf_agent_state\",\n          state: state,\n        }),\n      source !== \"server\" ? [source.id] : []\n    );\n    this.onStateUpdate(state, source);\n  }\n\n  setState(state: State) {\n    this.#setStateInternal(state, \"server\");\n  }\n\n  #warnedToImplementOnStateUpdate = false;\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    if (!this.#warnedToImplementOnStateUpdate) {\n      console.log(\n        \"state updated, implement onStateUpdate in your agent to handle this change\"\n      );\n      this.#warnedToImplementOnStateUpdate = true;\n    }\n  }\n\n  // onMessage(connection: Connection, message: WSMessage) {}\n\n  // onConnect(connection: Connection, ctx: ConnectionContext) {}\n\n  onEmail(email: ForwardableEmailMessage) {\n    throw new Error(\"Not implemented\");\n  }\n  render() {\n    throw new Error(\"Not implemented\");\n  }\n\n  async schedule<T = string>(\n    when: Date | string | number,\n    callback: string,\n    payload: T\n  ): Promise<Schedule<T>> {\n    const id = nanoid(9);\n\n    if (when instanceof Date) {\n      const timestamp = Math.floor(when.getTime() / 1000);\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n        payload\n      )}, 'scheduled', ${timestamp})\n      `;\n\n      await this.scheduleNextAlarm();\n\n      return {\n        id,\n        callback,\n        payload,\n        time: timestamp,\n        type: \"scheduled\",\n      };\n    } else if (typeof when === \"number\") {\n      const time = new Date(Date.now() + when * 1000);\n      const timestamp = Math.floor(time.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n        payload\n      )}, 'delayed', ${when}, ${timestamp})\n      `;\n\n      await this.scheduleNextAlarm();\n\n      return {\n        id,\n        callback,\n        payload,\n        delayInSeconds: when,\n        time: timestamp,\n        type: \"delayed\",\n      };\n    } else if (typeof when === \"string\") {\n      const nextExecutionTime = getNextCronTime(when);\n      const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n        payload\n      )}, 'cron', ${when}, ${timestamp})\n      `;\n\n      await this.scheduleNextAlarm();\n\n      return {\n        id,\n        callback,\n        payload,\n        cron: when,\n        time: timestamp,\n        type: \"cron\",\n      };\n    } else {\n      throw new Error(\"Invalid schedule type\");\n    }\n  }\n  async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE id = ${id}\n    `;\n    if (!result) return undefined;\n\n    return { ...result[0], payload: JSON.parse(result[0].payload) as T };\n  }\n  getSchedules<T = string>(\n    criteria: {\n      description?: string;\n      id?: string;\n      type?: \"scheduled\" | \"delayed\" | \"cron\";\n      timeRange?: { start?: Date; end?: Date };\n    } = {}\n  ): Schedule<T>[] {\n    let query = \"SELECT * FROM cf_agents_schedules WHERE 1=1\";\n    const params = [];\n\n    if (criteria.id) {\n      query += \" AND id = ?\";\n      params.push(criteria.id);\n    }\n\n    if (criteria.description) {\n      query += \" AND description = ?\";\n      params.push(criteria.description);\n    }\n\n    if (criteria.type) {\n      query += \" AND type = ?\";\n      params.push(criteria.type);\n    }\n\n    if (criteria.timeRange) {\n      query += \" AND time >= ? AND time <= ?\";\n      const start = criteria.timeRange.start || new Date(0);\n      const end = criteria.timeRange.end || new Date(999999999999999);\n      params.push(\n        Math.floor(start.getTime() / 1000),\n        Math.floor(end.getTime() / 1000)\n      );\n    }\n\n    const result = this.ctx.storage.sql\n      .exec(query, ...params)\n      .toArray()\n      .map((row) => ({\n        ...row,\n        payload: JSON.parse(row.payload as string) as T,\n      })) as Schedule<T>[];\n\n    return result;\n  }\n\n  async cancelSchedule(id: string): Promise<boolean> {\n    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;\n\n    await this.scheduleNextAlarm();\n    return true;\n  }\n\n  private async scheduleNextAlarm() {\n    // Find the next schedule that needs to be executed\n    const result = this.sql`\n      SELECT time FROM cf_agents_schedules \n      WHERE time > ${Math.floor(Date.now() / 1000)}\n      ORDER BY time ASC \n      LIMIT 1\n    `;\n    if (!result) return;\n\n    if (result.length > 0 && \"time\" in result[0]) {\n      const nextTime = result[0].time * 1000;\n      await this.ctx.storage.setAlarm(nextTime);\n    }\n  }\n\n  async alarm() {\n    const now = Math.floor(Date.now() / 1000);\n\n    // Get all schedules that should be executed now\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE time <= ${now}\n    `;\n\n    for (const row of result || []) {\n      const callback = this[row.callback as keyof Agent<Env>];\n      if (!callback) {\n        console.error(`callback ${row.callback} not found`);\n        continue;\n      }\n      try {\n        (\n          callback as (\n            payload: unknown,\n            schedule: Schedule<unknown>\n          ) => Promise<void>\n        ).bind(this)(JSON.parse(row.payload as string), row);\n      } catch (e) {\n        console.error(`error executing callback ${row.callback}`, e);\n      }\n      if (row.type === \"cron\") {\n        // Update next execution time for cron schedules\n        const nextExecutionTime = getNextCronTime(row.cron);\n        const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n        this.sql`\n          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}\n        `;\n      } else {\n        // Delete one-time schedules after execution\n        this.sql`\n          DELETE FROM cf_agents_schedules WHERE id = ${row.id}\n        `;\n      }\n    }\n\n    // Schedule the next alarm\n    await this.scheduleNextAlarm();\n  }\n\n  async destroy() {\n    // drop all tables\n    this.sql`DROP TABLE IF EXISTS cf_agents_state`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;\n\n    // delete all alarms\n    await this.ctx.storage.deleteAlarm();\n    await this.ctx.storage.deleteAll();\n  }\n}\n\nexport type AgentNamespace<Agentic extends Agent<unknown>> =\n  DurableObjectNamespace<Agentic>;\n\nexport type AgentContext = DurableObjectState;\n\nexport type AgentOptions<Env> = PartyServerOptions<Env>;\n\nexport function routeAgentRequest<Env>(\n  request: Request,\n  env: Env,\n  options?: AgentOptions<Env>\n) {\n  return routePartykitRequest(request, env as Record<string, unknown>, {\n    prefix: \"agents\",\n    ...(options as PartyServerOptions<Record<string, unknown>>),\n  });\n}\n\nexport async function routeAgentEmail<Env>(\n  email: ForwardableEmailMessage,\n  env: Env,\n  options?: AgentOptions<Env>\n): Promise<void> {}\n\nexport function getAgentByName<Env, T extends Agent<Env>>(\n  namespace: AgentNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n  }\n) {\n  return getServerByName<Env, T>(namespace, name, options);\n}\n"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EAEA;AAAA,OAIK;AAEP,SAAS,2BAA2B;AACpC,SAAS,cAAc;AAIvB,SAAS,sBAAsB,4BAA4B;AAEpD,IAAM,qBAAN,cAAiC,qBAAqB;AAAC;AAuB9D,SAAS,gBAAgB,MAAc;AACrC,QAAM,WAAW,oBAAoB,IAAI;AACzC,SAAO,SAAS,YAAY;AAC9B;AAEA,IAAM,eAAe;AAEd,IAAM,QAAN,cAA0C,OAAY;AAAA,EAC3D,SAAS;AAAA,EACT;AAAA,EAEA,OAAO,UAAU;AAAA,IACf,WAAW;AAAA;AAAA,EACb;AAAA,EACA,IACE,YACG,QACH;AACA,QAAI,QAAQ;AACZ,QAAI;AAEF,cAAQ,QAAQ;AAAA,QACd,CAAC,KAAK,KAAK,MAAM,MAAM,OAAO,IAAI,OAAO,SAAS,MAAM;AAAA,QACxD;AAAA,MACF;AAGA,aAAO,CAAC,GAAG,KAAK,IAAI,QAAQ,IAAI,KAAK,OAAO,GAAG,MAAM,CAAC;AAAA,IACxD,SAAS,GAAG;AACV,cAAQ,MAAM,gCAAgC,KAAK,IAAI,CAAC;AACxD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,YAAY,KAAmB,KAAU;AACvC,UAAM,KAAK,GAAG;AAEd,SAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAML,UAAM,QAAQ;AACd,WAAO,eAAe,MAAM,SAAS;AAAA,MACnC,MAAM;AACJ,YAAI,CAAC,MAAM,QAAQ;AACjB,gBAAM,SAAS,MAAM;AAAA,qDACsB,YAAY;AAAA;AAEvD,gBAAM,QAAQ,OAAO,CAAC,GAAG;AACzB,cAAI,CAAC,MAAO,QAAO;AACnB,gBAAM,SAAS,KAAK,MAAM,KAAK;AAC/B,iBAAO,MAAM;AAAA,QACf;AACA,eAAO,MAAM;AAAA,MACf;AAAA,MACA,IAAI,OAA0B;AAC5B,cAAM,IAAI,MAAM,+CAA+C;AAAA,MACjE;AAAA,IACF,CAAC;AAED,SAAK,KAAK,IAAI,sBAAsB,YAAY;AAC9C,UAAI;AAEF,aAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcL,cAAM,KAAK,MAAM;AAAA,MACnB,SAAS,GAAG;AACV,gBAAQ,MAAM,CAAC;AACf,cAAM;AAAA,MACR;AAAA,IACF,CAAC;AAED,UAAM,aAAa,KAAK,UAAU,KAAK,IAAI;AAC3C,SAAK,YAAY,CAAC,YAAwB,YAAuB;AAC/D,UACE,OAAO,YAAY,YACnB,QAAQ,WAAW,iBAAiB,GACpC;AACA,cAAM,SAAS,KAAK,MAAM,QAAQ,MAAM,EAAE,CAAC;AAC3C,aAAK,kBAAkB,OAAO,OAAO,UAAU;AAC/C;AAAA,MACF;AACA,iBAAW,YAAY,OAAO;AAAA,IAChC;AAEA,UAAM,aAAa,KAAK,UAAU,KAAK,IAAI;AAC3C,SAAK,YAAY,CAAC,YAAwBA,SAA2B;AAGnE,iBAAW,MAAM;AACf,YAAI,KAAK,OAAO;AACd,qBAAW;AAAA,YACT,oBACE,KAAK,UAAU,EAAE,MAAM,kBAAkB,OAAO,KAAK,MAAM,CAAC;AAAA,UAChE;AAAA,QACF;AACA,mBAAW,YAAYA,IAAG;AAAA,MAC5B,GAAG,EAAE;AAAA,IACP;AAAA,EACF;AAAA,EAEA,kBAAkB,OAAc,SAAgC,UAAU;AACxE,SAAK,SAAS;AACd,SAAK;AAAA;AAAA,cAEK,YAAY,KAAK,KAAK,UAAU,KAAK,CAAC;AAAA;AAEhD,SAAK;AAAA,MACH,oBACE,KAAK,UAAU;AAAA,QACb,MAAM;AAAA,QACN;AAAA,MACF,CAAC;AAAA,MACH,WAAW,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC;AAAA,IACvC;AACA,SAAK,cAAc,OAAO,MAAM;AAAA,EAClC;AAAA,EAEA,SAAS,OAAc;AACrB,SAAK,kBAAkB,OAAO,QAAQ;AAAA,EACxC;AAAA,EAEA,kCAAkC;AAAA,EAClC,cAAc,OAA0B,QAA+B;AACrE,QAAI,CAAC,KAAK,iCAAiC;AACzC,cAAQ;AAAA,QACN;AAAA,MACF;AACA,WAAK,kCAAkC;AAAA,IACzC;AAAA,EACF;AAAA;AAAA;AAAA,EAMA,QAAQ,OAAgC;AACtC,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AAAA,EACA,SAAS;AACP,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AAAA,EAEA,MAAM,SACJ,MACA,UACA,SACsB;AACtB,UAAM,KAAK,OAAO,CAAC;AAEnB,QAAI,gBAAgB,MAAM;AACxB,YAAM,YAAY,KAAK,MAAM,KAAK,QAAQ,IAAI,GAAI;AAClD,WAAK;AAAA;AAAA,kBAEO,EAAE,KAAK,QAAQ,KAAK,KAAK;AAAA,QACnC;AAAA,MACF,CAAC,kBAAkB,SAAS;AAAA;AAG5B,YAAM,KAAK,kBAAkB;AAE7B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IACF,WAAW,OAAO,SAAS,UAAU;AACnC,YAAM,OAAO,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,GAAI;AAC9C,YAAM,YAAY,KAAK,MAAM,KAAK,QAAQ,IAAI,GAAI;AAElD,WAAK;AAAA;AAAA,kBAEO,EAAE,KAAK,QAAQ,KAAK,KAAK;AAAA,QACnC;AAAA,MACF,CAAC,gBAAgB,IAAI,KAAK,SAAS;AAAA;AAGnC,YAAM,KAAK,kBAAkB;AAE7B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,QAChB,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IACF,WAAW,OAAO,SAAS,UAAU;AACnC,YAAM,oBAAoB,gBAAgB,IAAI;AAC9C,YAAM,YAAY,KAAK,MAAM,kBAAkB,QAAQ,IAAI,GAAI;AAE/D,WAAK;AAAA;AAAA,kBAEO,EAAE,KAAK,QAAQ,KAAK,KAAK;AAAA,QACnC;AAAA,MACF,CAAC,aAAa,IAAI,KAAK,SAAS;AAAA;AAGhC,YAAM,KAAK,kBAAkB;AAE7B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IACF,OAAO;AACL,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAAA,EACF;AAAA,EACA,MAAM,YAAwB,IAA8C;AAC1E,UAAM,SAAS,KAAK;AAAA,qDAC6B,EAAE;AAAA;AAEnD,QAAI,CAAC,OAAQ,QAAO;AAEpB,WAAO,EAAE,GAAG,OAAO,CAAC,GAAG,SAAS,KAAK,MAAM,OAAO,CAAC,EAAE,OAAO,EAAO;AAAA,EACrE;AAAA,EACA,aACE,WAKI,CAAC,GACU;AACf,QAAI,QAAQ;AACZ,UAAM,SAAS,CAAC;AAEhB,QAAI,SAAS,IAAI;AACf,eAAS;AACT,aAAO,KAAK,SAAS,EAAE;AAAA,IACzB;AAEA,QAAI,SAAS,aAAa;AACxB,eAAS;AACT,aAAO,KAAK,SAAS,WAAW;AAAA,IAClC;AAEA,QAAI,SAAS,MAAM;AACjB,eAAS;AACT,aAAO,KAAK,SAAS,IAAI;AAAA,IAC3B;AAEA,QAAI,SAAS,WAAW;AACtB,eAAS;AACT,YAAM,QAAQ,SAAS,UAAU,SAAS,oBAAI,KAAK,CAAC;AACpD,YAAM,MAAM,SAAS,UAAU,OAAO,oBAAI,KAAK,eAAe;AAC9D,aAAO;AAAA,QACL,KAAK,MAAM,MAAM,QAAQ,IAAI,GAAI;AAAA,QACjC,KAAK,MAAM,IAAI,QAAQ,IAAI,GAAI;AAAA,MACjC;AAAA,IACF;AAEA,UAAM,SAAS,KAAK,IAAI,QAAQ,IAC7B,KAAK,OAAO,GAAG,MAAM,EACrB,QAAQ,EACR,IAAI,CAAC,SAAS;AAAA,MACb,GAAG;AAAA,MACH,SAAS,KAAK,MAAM,IAAI,OAAiB;AAAA,IAC3C,EAAE;AAEJ,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,eAAe,IAA8B;AACjD,SAAK,iDAAiD,EAAE;AAExD,UAAM,KAAK,kBAAkB;AAC7B,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,oBAAoB;AAEhC,UAAM,SAAS,KAAK;AAAA;AAAA,qBAEH,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI,CAAC;AAAA;AAAA;AAAA;AAI9C,QAAI,CAAC,OAAQ;AAEb,QAAI,OAAO,SAAS,KAAK,UAAU,OAAO,CAAC,GAAG;AAC5C,YAAM,WAAW,OAAO,CAAC,EAAE,OAAO;AAClC,YAAM,KAAK,IAAI,QAAQ,SAAS,QAAQ;AAAA,IAC1C;AAAA,EACF;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAGxC,UAAM,SAAS,KAAK;AAAA,wDACgC,GAAG;AAAA;AAGvD,eAAW,OAAO,UAAU,CAAC,GAAG;AAC9B,YAAM,WAAW,KAAK,IAAI,QAA4B;AACtD,UAAI,CAAC,UAAU;AACb,gBAAQ,MAAM,YAAY,IAAI,QAAQ,YAAY;AAClD;AAAA,MACF;AACA,UAAI;AACF,QACE,SAIA,KAAK,IAAI,EAAE,KAAK,MAAM,IAAI,OAAiB,GAAG,GAAG;AAAA,MACrD,SAAS,GAAG;AACV,gBAAQ,MAAM,4BAA4B,IAAI,QAAQ,IAAI,CAAC;AAAA,MAC7D;AACA,UAAI,IAAI,SAAS,QAAQ;AAEvB,cAAM,oBAAoB,gBAAgB,IAAI,IAAI;AAClD,cAAM,gBAAgB,KAAK,MAAM,kBAAkB,QAAQ,IAAI,GAAI;AAEnE,aAAK;AAAA,kDACqC,aAAa,eAAe,IAAI,EAAE;AAAA;AAAA,MAE9E,OAAO;AAEL,aAAK;AAAA,uDAC0C,IAAI,EAAE;AAAA;AAAA,MAEvD;AAAA,IACF;AAGA,UAAM,KAAK,kBAAkB;AAAA,EAC/B;AAAA,EAEA,MAAM,UAAU;AAEd,SAAK;AACL,SAAK;AAGL,UAAM,KAAK,IAAI,QAAQ,YAAY;AACnC,UAAM,KAAK,IAAI,QAAQ,UAAU;AAAA,EACnC;AACF;AASO,SAAS,kBACd,SACA,KACA,SACA;AACA,SAAO,qBAAqB,SAAS,KAAgC;AAAA,IACnE,QAAQ;AAAA,IACR,GAAI;AAAA,EACN,CAAC;AACH;AAEA,eAAsB,gBACpB,OACA,KACA,SACe;AAAC;AAEX,SAAS,eACd,WACA,MACA,SAIA;AACA,SAAO,gBAAwB,WAAW,MAAM,OAAO;AACzD;","names":["ctx"]}