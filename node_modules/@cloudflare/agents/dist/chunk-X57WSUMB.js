// src/index.ts
import {
  Server,
  routePartykitRequest,
  getServerByName
} from "partyserver";
import { parseCronExpression } from "cron-schedule";
import { nanoid } from "nanoid";
import { WorkflowEntrypoint as CFWorkflowEntrypoint } from "cloudflare:workers";
var WorkflowEntrypoint = class extends CFWorkflowEntrypoint {
};
function getNextCronTime(cron) {
  const interval = parseCronExpression(cron);
  return interval.getNextDate();
}
var STATE_ROW_ID = "cf_state_row_id";
var Agent = class extends Server {
  #state = void 0;
  state;
  static options = {
    hibernate: true
    // default to hibernate
  };
  sql(strings, ...values) {
    let query = "";
    try {
      query = strings.reduce(
        (acc, str, i) => acc + str + (i < values.length ? "?" : ""),
        ""
      );
      return [...this.ctx.storage.sql.exec(query, ...values)];
    } catch (e) {
      console.error(`failed to execute sql query: ${query}`, e);
      throw e;
    }
  }
  constructor(ctx, env) {
    super(ctx, env);
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_state (
        id TEXT PRIMARY KEY NOT NULL,
        state TEXT
      )
    `;
    const _this = this;
    Object.defineProperty(this, "state", {
      get() {
        if (!_this.#state) {
          const result = _this.sql`
      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}
    `;
          const state = result[0]?.state;
          if (!state) return void 0;
          _this.#state = JSON.parse(state);
          return _this.#state;
        }
        return _this.#state;
      },
      set(value) {
        throw new Error("State is read-only, use this.setState instead");
      }
    });
    void this.ctx.blockConcurrencyWhile(async () => {
      try {
        this.sql`
        CREATE TABLE IF NOT EXISTS cf_agents_schedules (
          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
          callback TEXT,
          payload TEXT,
          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),
          time INTEGER,
          delayInSeconds INTEGER,
          cron TEXT,
          created_at INTEGER DEFAULT (unixepoch())
        )
      `;
        await this.alarm();
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const _onMessage = this.onMessage.bind(this);
    this.onMessage = (connection, message) => {
      if (typeof message === "string" && message.startsWith("cf_agent_state:")) {
        const parsed = JSON.parse(message.slice(15));
        this.#setStateInternal(parsed.state, connection);
        return;
      }
      _onMessage(connection, message);
    };
    const _onConnect = this.onConnect.bind(this);
    this.onConnect = (connection, ctx2) => {
      setTimeout(() => {
        if (this.state) {
          connection.send(
            `cf_agent_state:` + JSON.stringify({ type: "cf_agent_state", state: this.state })
          );
        }
        _onConnect(connection, ctx2);
      }, 20);
    };
  }
  #setStateInternal(state, source = "server") {
    this.#state = state;
    this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})
  `;
    this.broadcast(
      `cf_agent_state:` + JSON.stringify({
        type: "cf_agent_state",
        state
      }),
      source !== "server" ? [source.id] : []
    );
    this.onStateUpdate(state, source);
  }
  setState(state) {
    this.#setStateInternal(state, "server");
  }
  #warnedToImplementOnStateUpdate = false;
  onStateUpdate(state, source) {
    if (!this.#warnedToImplementOnStateUpdate) {
      console.log(
        "state updated, implement onStateUpdate in your agent to handle this change"
      );
      this.#warnedToImplementOnStateUpdate = true;
    }
  }
  // onMessage(connection: Connection, message: WSMessage) {}
  // onConnect(connection: Connection, ctx: ConnectionContext) {}
  onEmail(email) {
    throw new Error("Not implemented");
  }
  render() {
    throw new Error("Not implemented");
  }
  async schedule(when, callback, payload) {
    const id = nanoid(9);
    if (when instanceof Date) {
      const timestamp = Math.floor(when.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'scheduled', ${timestamp})
      `;
      await this.scheduleNextAlarm();
      return {
        id,
        callback,
        payload,
        time: timestamp,
        type: "scheduled"
      };
    } else if (typeof when === "number") {
      const time = new Date(Date.now() + when * 1e3);
      const timestamp = Math.floor(time.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'delayed', ${when}, ${timestamp})
      `;
      await this.scheduleNextAlarm();
      return {
        id,
        callback,
        payload,
        delayInSeconds: when,
        time: timestamp,
        type: "delayed"
      };
    } else if (typeof when === "string") {
      const nextExecutionTime = getNextCronTime(when);
      const timestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'cron', ${when}, ${timestamp})
      `;
      await this.scheduleNextAlarm();
      return {
        id,
        callback,
        payload,
        cron: when,
        time: timestamp,
        type: "cron"
      };
    } else {
      throw new Error("Invalid schedule type");
    }
  }
  async getSchedule(id) {
    const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE id = ${id}
    `;
    if (!result) return void 0;
    return { ...result[0], payload: JSON.parse(result[0].payload) };
  }
  getSchedules(criteria = {}) {
    let query = "SELECT * FROM cf_agents_schedules WHERE 1=1";
    const params = [];
    if (criteria.id) {
      query += " AND id = ?";
      params.push(criteria.id);
    }
    if (criteria.description) {
      query += " AND description = ?";
      params.push(criteria.description);
    }
    if (criteria.type) {
      query += " AND type = ?";
      params.push(criteria.type);
    }
    if (criteria.timeRange) {
      query += " AND time >= ? AND time <= ?";
      const start = criteria.timeRange.start || /* @__PURE__ */ new Date(0);
      const end = criteria.timeRange.end || /* @__PURE__ */ new Date(999999999999999);
      params.push(
        Math.floor(start.getTime() / 1e3),
        Math.floor(end.getTime() / 1e3)
      );
    }
    const result = this.ctx.storage.sql.exec(query, ...params).toArray().map((row) => ({
      ...row,
      payload: JSON.parse(row.payload)
    }));
    return result;
  }
  async cancelSchedule(id) {
    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;
    await this.scheduleNextAlarm();
    return true;
  }
  async scheduleNextAlarm() {
    const result = this.sql`
      SELECT time FROM cf_agents_schedules 
      WHERE time > ${Math.floor(Date.now() / 1e3)}
      ORDER BY time ASC 
      LIMIT 1
    `;
    if (!result) return;
    if (result.length > 0 && "time" in result[0]) {
      const nextTime = result[0].time * 1e3;
      await this.ctx.storage.setAlarm(nextTime);
    }
  }
  async alarm() {
    const now = Math.floor(Date.now() / 1e3);
    const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE time <= ${now}
    `;
    for (const row of result || []) {
      const callback = this[row.callback];
      if (!callback) {
        console.error(`callback ${row.callback} not found`);
        continue;
      }
      try {
        callback.bind(this)(JSON.parse(row.payload), row);
      } catch (e) {
        console.error(`error executing callback ${row.callback}`, e);
      }
      if (row.type === "cron") {
        const nextExecutionTime = getNextCronTime(row.cron);
        const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
        this.sql`
          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}
        `;
      } else {
        this.sql`
          DELETE FROM cf_agents_schedules WHERE id = ${row.id}
        `;
      }
    }
    await this.scheduleNextAlarm();
  }
  async destroy() {
    this.sql`DROP TABLE IF EXISTS cf_agents_state`;
    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;
    await this.ctx.storage.deleteAlarm();
    await this.ctx.storage.deleteAll();
  }
};
function routeAgentRequest(request, env, options) {
  return routePartykitRequest(request, env, {
    prefix: "agents",
    ...options
  });
}
async function routeAgentEmail(email, env, options) {
}
function getAgentByName(namespace, name, options) {
  return getServerByName(namespace, name, options);
}

export {
  WorkflowEntrypoint,
  Agent,
  routeAgentRequest,
  routeAgentEmail,
  getAgentByName
};
//# sourceMappingURL=chunk-X57WSUMB.js.map