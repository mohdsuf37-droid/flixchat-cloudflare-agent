{"version":3,"sources":["../src/ai-chat-agent.ts"],"sourcesContent":["import { Agent, type AgentContext, type Connection, type WSMessage } from \"./\";\nimport type { Message as ChatMessage, StreamTextOnFinishCallback } from \"ai\";\nimport { appendResponseMessages } from \"ai\";\nimport type { OutgoingMessage, IncomingMessage } from \"./ai-types\";\nconst decoder = new TextDecoder();\n\nexport class AIChatAgent<Env = unknown> extends Agent<Env> {\n  messages: ChatMessage[];\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n    this.sql`create table if not exists cf_ai_chat_agent_messages (\n      id text primary key,\n      message text not null,\n      created_at datetime default current_timestamp\n    )`;\n    this.messages = (\n      this.sql`select * from cf_ai_chat_agent_messages` || []\n    ).map((row) => {\n      return JSON.parse(row.message);\n    });\n  }\n\n  private sendChatMessage(connection: Connection, message: OutgoingMessage) {\n    try {\n      connection.send(JSON.stringify(message));\n    } catch (e) {\n      // silently ignore\n    }\n  }\n\n  private broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {\n    try {\n      this.broadcast(JSON.stringify(message), exclude);\n    } catch (e) {\n      // silently ignore\n    }\n  }\n\n  override async onMessage(connection: Connection, message: WSMessage) {\n    if (typeof message === \"string\") {\n      const data = JSON.parse(message) as IncomingMessage;\n      if (data.type == \"cf_agent_chat_init\") {\n        connection.setState({\n          ...connection.state,\n          isChatConnection: true,\n        });\n      } else if (\n        data.type === \"cf_agent_use_chat_request\" &&\n        data.init.method === \"POST\"\n      ) {\n        const {\n          method,\n          keepalive,\n          headers,\n          body, // we're reading this\n          redirect,\n          integrity,\n          credentials,\n          mode,\n          referrer,\n          referrerPolicy,\n          window,\n          // dispatcher,\n          // duplex\n        } = data.init;\n        const { messages } = JSON.parse(body as string);\n        this.broadcastChatMessage(\n          {\n            type: \"cf_agent_chat_messages\",\n            messages,\n          },\n          [connection.id]\n        );\n        await this.persistMessages(messages, [connection.id]);\n        const response = await this.onChatMessage(async ({ response }) => {\n          const finalMessages = appendResponseMessages({\n            messages,\n            responseMessages: response.messages,\n          });\n\n          await this.persistMessages(finalMessages, [connection.id]);\n        });\n        if (response) {\n          await this.reply(data.id, response);\n        }\n      } else if (data.type === \"cf_agent_chat_clear\") {\n        this.sql`delete from cf_ai_chat_agent_messages`;\n        this.messages = [];\n        this.broadcastChatMessage(\n          {\n            type: \"cf_agent_chat_clear\",\n          },\n          [connection.id]\n        );\n      } else if (data.type === \"cf_agent_chat_messages\") {\n        // replace the messages with the new ones\n        await this.persistMessages(data.messages, [connection.id]);\n      }\n    }\n  }\n\n  override async onRequest(request: Request): Promise<Response> {\n    if (request.url.endsWith(\"/get-messages\")) {\n      const messages = (\n        this.sql`select * from cf_ai_chat_agent_messages` || []\n      ).map((row) => {\n        return JSON.parse(row.message);\n      });\n      return new Response(JSON.stringify(messages));\n    }\n    return super.onRequest(request);\n  }\n\n  /*\n   * override this to handle incoming messages\n   * @param onFinish - a callback that is called when the response is finished\n   * @returns a Response to send to the client\n   */\n  async onChatMessage(\n    onFinish: StreamTextOnFinishCallback<any>\n  ): Promise<Response | undefined> {\n    throw new Error(\n      \"recieved a chat message, override onChatMessage and return a Response to send to the client\"\n    );\n  }\n\n  /*\n   * You can save messages on the server side\n   */\n  async saveMessages(messages: ChatMessage[]) {\n    await this.persistMessages(messages);\n    const response = await this.onChatMessage(async ({ response }) => {\n      const finalMessages = appendResponseMessages({\n        messages,\n        responseMessages: response.messages,\n      });\n\n      await this.persistMessages(finalMessages, []);\n    });\n    if (response) {\n      // we're just going to drain the body\n      // @ts-ignore TODO: fix this type error\n      for await (const chunk of response.body!) {\n        decoder.decode(chunk);\n      }\n      response.body?.cancel();\n    }\n  }\n\n  private async persistMessages(\n    messages: ChatMessage[],\n    excludeBroadcastIds: string[] = []\n  ) {\n    this.sql`delete from cf_ai_chat_agent_messages`;\n    messages.forEach((message) => {\n      this.sql`insert into cf_ai_chat_agent_messages (id, message) values (${\n        message.id\n      },${JSON.stringify(message)})`;\n    });\n    this.messages = messages;\n    this.broadcastChatMessage(\n      {\n        type: \"cf_agent_chat_messages\",\n        messages: messages,\n      },\n      excludeBroadcastIds\n    );\n  }\n\n  private async reply(id: string, response: Response) {\n    const chatConnections = [...this.getConnections()].filter(\n      (conn: Connection<{ isChatConnection?: boolean }>) =>\n        conn.state?.isChatConnection\n    );\n    // now take chunks out from dataStreamResponse and send them to the client\n\n    // @ts-ignore TODO: fix this type error\n    for await (const chunk of response.body!) {\n      const body = decoder.decode(chunk);\n\n      chatConnections.forEach((conn) => {\n        this.sendChatMessage(conn, {\n          id,\n          type: \"cf_agent_use_chat_response\",\n          body,\n          done: false,\n        });\n      });\n    }\n\n    chatConnections.forEach((conn) => {\n      this.sendChatMessage(conn, {\n        id,\n        type: \"cf_agent_use_chat_response\",\n        body: \"\",\n        done: true,\n      });\n    });\n  }\n}\n"],"mappings":"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","names":["response"]}