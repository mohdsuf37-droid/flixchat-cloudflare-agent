import {
  Agent
} from "./chunk-X57WSUMB.js";

// src/ai-chat-agent.ts
import { appendResponseMessages } from "ai";
var decoder = new TextDecoder();
var AIChatAgent = class extends Agent {
  messages;
  constructor(ctx, env) {
    super(ctx, env);
    this.sql`create table if not exists cf_ai_chat_agent_messages (
      id text primary key,
      message text not null,
      created_at datetime default current_timestamp
    )`;
    this.messages = (this.sql`select * from cf_ai_chat_agent_messages` || []).map((row) => {
      return JSON.parse(row.message);
    });
  }
  sendChatMessage(connection, message) {
    try {
      connection.send(JSON.stringify(message));
    } catch (e) {
    }
  }
  broadcastChatMessage(message, exclude) {
    try {
      this.broadcast(JSON.stringify(message), exclude);
    } catch (e) {
    }
  }
  async onMessage(connection, message) {
    if (typeof message === "string") {
      const data = JSON.parse(message);
      if (data.type == "cf_agent_chat_init") {
        connection.setState({
          ...connection.state,
          isChatConnection: true
        });
      } else if (data.type === "cf_agent_use_chat_request" && data.init.method === "POST") {
        const {
          method,
          keepalive,
          headers,
          body,
          // we're reading this
          redirect,
          integrity,
          credentials,
          mode,
          referrer,
          referrerPolicy,
          window
          // dispatcher,
          // duplex
        } = data.init;
        const { messages } = JSON.parse(body);
        this.broadcastChatMessage(
          {
            type: "cf_agent_chat_messages",
            messages
          },
          [connection.id]
        );
        await this.persistMessages(messages, [connection.id]);
        const response = await this.onChatMessage(async ({ response: response2 }) => {
          const finalMessages = appendResponseMessages({
            messages,
            responseMessages: response2.messages
          });
          await this.persistMessages(finalMessages, [connection.id]);
        });
        if (response) {
          await this.reply(data.id, response);
        }
      } else if (data.type === "cf_agent_chat_clear") {
        this.sql`delete from cf_ai_chat_agent_messages`;
        this.messages = [];
        this.broadcastChatMessage(
          {
            type: "cf_agent_chat_clear"
          },
          [connection.id]
        );
      } else if (data.type === "cf_agent_chat_messages") {
        await this.persistMessages(data.messages, [connection.id]);
      }
    }
  }
  async onRequest(request) {
    if (request.url.endsWith("/get-messages")) {
      const messages = (this.sql`select * from cf_ai_chat_agent_messages` || []).map((row) => {
        return JSON.parse(row.message);
      });
      return new Response(JSON.stringify(messages));
    }
    return super.onRequest(request);
  }
  /*
   * override this to handle incoming messages
   * @param onFinish - a callback that is called when the response is finished
   * @returns a Response to send to the client
   */
  async onChatMessage(onFinish) {
    throw new Error(
      "recieved a chat message, override onChatMessage and return a Response to send to the client"
    );
  }
  /*
   * You can save messages on the server side
   */
  async saveMessages(messages) {
    await this.persistMessages(messages);
    const response = await this.onChatMessage(async ({ response: response2 }) => {
      const finalMessages = appendResponseMessages({
        messages,
        responseMessages: response2.messages
      });
      await this.persistMessages(finalMessages, []);
    });
    if (response) {
      for await (const chunk of response.body) {
        decoder.decode(chunk);
      }
      response.body?.cancel();
    }
  }
  async persistMessages(messages, excludeBroadcastIds = []) {
    this.sql`delete from cf_ai_chat_agent_messages`;
    messages.forEach((message) => {
      this.sql`insert into cf_ai_chat_agent_messages (id, message) values (${message.id},${JSON.stringify(message)})`;
    });
    this.messages = messages;
    this.broadcastChatMessage(
      {
        type: "cf_agent_chat_messages",
        messages
      },
      excludeBroadcastIds
    );
  }
  async reply(id, response) {
    const chatConnections = [...this.getConnections()].filter(
      (conn) => conn.state?.isChatConnection
    );
    for await (const chunk of response.body) {
      const body = decoder.decode(chunk);
      chatConnections.forEach((conn) => {
        this.sendChatMessage(conn, {
          id,
          type: "cf_agent_use_chat_response",
          body,
          done: false
        });
      });
    }
    chatConnections.forEach((conn) => {
      this.sendChatMessage(conn, {
        id,
        type: "cf_agent_use_chat_response",
        body: "",
        done: true
      });
    });
  }
};
export {
  AIChatAgent
};
//# sourceMappingURL=ai-chat-agent.js.map